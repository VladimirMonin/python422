"""
Lesson 42.
ООП Python
Магические методы для арифметических операций
Датаклассы
  - Мутабельность 
  - post_init
  - __slots__
  - field свойства
    - factory
    - default
    - repr False
    - compare False
  - frozen=True
Абстрактные датаклассы и наследование в dataclass
  
"""
# Чем in-place мат. операция отличается от обычной?

"""
In-place операции изменяют исходный объект, а обычные операции создают новый объект с результатом.
Например: a += 1 изменяет a, а a + 1 создает новый объект
"""

# Обычные арифметические операции:
# __add__(self, other) -> +  # сложение
# __sub__(self, other) -> -  # вычитание
# __mul__(self, other) -> *  # умножение
# __truediv__(self, other) -> /  # деление
# __floordiv__(self, other) -> //  # целочисленное деление
# __mod__(self, other) -> %  # остаток от деления
# __pow__(self, other) -> **  # возведение в степень


# In-place операции (с присваиванием):
# __iadd__(self, other) -> +=  # сложение с присваиванием
# __isub__(self, other) -> -=  # вычитание с присваиванием
# __imul__(self, other) -> *=  # умножение с присваиванием
# __itruediv__(self, other) -> /=  # деление с присваиванием
# __ifloordiv__(self, other) -> //=  # целочисленное деление с присваиванием
# __imod__(self, other) -> %=  # остаток от деления с присваиванием
# __ipow__(self, other) -> **=  # возведение в степень с присваиванием

class Pizza:
    def __init__(self, size):
        self.size = size
    
    def __add__(self, other):
        """Создает новую пиццу с суммой размеров"""
        if not isinstance(other, Pizza):
            raise TypeError("Можно складывать только пиццы между собой")
        return Pizza(self.size + other.size)
    
    def __iadd__(self, other):
        """Создает новую пиццу с суммой размеров (in-place операция)"""
        if not isinstance(other, Pizza):
            raise TypeError("Можно складывать только пиццы между собой")
        return Pizza(self.size + other.size)    
    def __str__(self):
        return f"Пицца размера {self.size} см. ID: {id(self)}"


# Пример использования
pizza1 = Pizza(30)  # пицца диаметром 30 см
pizza2 = Pizza(25)  # пицца диаметром 25 см

# Обычное сложение
pizza3 = pizza1 + pizza2
print(pizza3)  # Пицца размера 55

print(pizza1)
# In-place сложение
pizza1 += pizza2
print(pizza1)  # Пицца размера 55

### Проверим, а что происходит со строками на инплейс операциях


product = "чебурек"
print(id(product))
product += "из кот"
print(id(product))

some_num = 1
print(id(some_num))
some_num += 1
print(id(some_num))

"""
Мутабельность коллекций в Python:

1. Мутабельные (изменяемые) коллекции:
   - list (списки)
   - dict (словари)
   - set (множества)
   Особенности:
   - можно изменять содержимое после создания
   - при модификации сохраняют свой id
   - передаются в функции по ссылке

2. Иммутабельные (неизменяемые) коллекции:
   - tuple (кортежи)
   - frozenset (неизменяемые множества)
   - str (строки)
   Особенности:
   - нельзя изменить после создания
   - при любой модификации создается новый объект с новым id
   - передаются в функции по значению

Пример с list (мутабельный):
"""
some_list = [1, 2, 3]
print(id(some_list))  # id сохраняется
some_list += [4, 5]   # изменяем список
print(id(some_list))  # id остается тем же

# При работе с изменяемыми коллекциями важно помнить о побочных эффектах
# при передаче их в функции или при создании копий
